/*
SE Basic IV 4.2 Cordelia
Copyright (c) 1999-2020 Source Solutions, Inc.

SE Basic IV is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

SE Basic IV is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty o;
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SE Basic IV. If not, see <http://www.gnu.org/licenses/>.
*/

#include <stdio.h>
#include <stdlib.h>

typedef unsigned char BYTE;
/*
	8		8		3	5	3	5
AAADDDDD AAADDDDD MRN JJJJJ MMM XXXXX

AAA	= semi-key of the keyboard to be modified				| this information is
DDDDD	= data (AND denied with what there is) of that semifila | repeated for two keys
MRN	= Master reset, User reset, NMI
JJJJJ	= joystick status when pressing key. UDLRX positions
MMM	= the key is a modifier
XXXXX = Reserved for future use

For example: in the memory address corresponding to the code of the ESC key,
that would correspond to the simultaneous press of CAPS SHIFT + SPACE, we would put:
00000001 11100001 000 00000 000 00000
This is: semifilas 0 and 7 are activated, and in each, bit 0 is activated

256 codes + E0 = 512 codes
SHIFT, CTRL, ALT = 8 combinations

512 * 8 = 4096 addresses x 32 bits = 16384 bytes
In the core it will be available as a memory of 16384x8 bits

Each key will occupy four consecutive addresses.
D + 0: key1 (or 0 if there is none)
D + 1: key2 (or 0 if there is none)
D + 2: reset signals and joystick, 0 if there is no
D + 3: modifiers and user signals, 0 if there is no
*/

// You shouldn't have to touch these defs unless your Uno has a different keyboard
// layout (because, for example, you are using a different ROM)
#define SE_1		0x61
#define SE_2		0x62
#define SE_3		0x64
#define SE_4		0x68
#define SE_5		0x70

#define SE_0		0x81
#define SE_9		0x82
#define SE_8		0x84
#define SE_7		0x88
#define SE_6		0x90

#define SE_Q		0x41
#define SE_W		0x42
#define SE_E		0x44
#define SE_R		0x48
#define SE_T		0x50

#define SE_P		0xA1
#define SE_O		0xA2
#define SE_I		0xA4
#define SE_U		0xA8
#define SE_Y		0xB0

#define SE_A		0x21
#define SE_S		0x22
#define SE_D		0x24
#define SE_F		0x28
#define SE_G		0x30

#define SE_RETURN	0xC1
#define SE_L		0xC2
#define SE_K		0xC4
#define SE_J		0xC8
#define SE_H		0xD0

#define SE_CAPS		0x01
#define SE_Z		0x02
#define SE_X		0x04
#define SE_C		0x08
#define SE_V		0x10

#define SE_SPACE	0xE1
#define SE_SYMB		0xE2
#define SE_M		0xE4
#define SE_N		0xE8
#define SE_B		0xF0

// matrix symbols
#define SE_EXCL		(SE_SYMB<<8) | SE_1	// !
#define SE_QUOT		(SE_SYMB<<8) | SE_P	// "
#define SE_NUM		(SE_SYMB<<8) | SE_3	// #
#define SE_DOLLAR	(SE_SYMB<<8) | SE_4	// $
#define SE_PERCEN	(SE_SYMB<<8) | SE_5	// %
#define SE_AMP		(SE_SYMB<<8) | SE_6	// &
#define SE_APOS 	(SE_SYMB<<8) | SE_7	// '
#define SE_LPAR		(SE_SYMB<<8) | SE_8	// (
#define SE_RPAR		(SE_SYMB<<8) | SE_9	// )
#define SE_AST		(SE_SYMB<<8) | SE_B	// *

#define SE_PLUS		(SE_SYMB<<8) | SE_K	// +
#define SE_COMMA	(SE_SYMB<<8) | SE_N	// ,
#define SE_MINUS	(SE_SYMB<<8) | SE_J	// -
#define SE_PERIOD	(SE_SYMB<<8) | SE_M	// .
#define SE_SOL		(SE_SYMB<<8) | SE_V	// /

#define SE_COLON	(SE_SYMB<<8) | SE_Z	// :
#define SE_SEMI		(SE_SYMB<<8) | SE_O	// ;
#define SE_LT		(SE_SYMB<<8) | SE_R	// <
#define SE_EQUALS	(SE_SYMB<<8) | SE_L	// =
#define SE_GT 		(SE_SYMB<<8) | SE_T	// >
#define SE_QUEST	(SE_SYMB<<8) | SE_C	// ?
#define SE_COMMAT	(SE_SYMB<<8) | SE_2	// @
#define SE_LSQB		(SE_SYMB<<8) | SE_Y	// [
#define SE_BSOL		(SE_SYMB<<8) | SE_D	// \ 
#define SE_RSQB		(SE_SYMB<<8) | SE_U	// ]
#define SE_CARET	(SE_SYMB<<8) | SE_H	// ^
#define SE_LOWBAR	(SE_SYMB<<8) | SE_0	// _
#define SE_GRAVE	(SE_SYMB<<8) | SE_X	// `

#define SE_LCUB		(SE_SYMB<<8) | SE_F	// {
#define SE_VERBAR	(SE_SYMB<<8) | SE_S	// |
#define SE_RCUB 	(SE_SYMB<<8) | SE_G	// }
#define SE_TILDE	(SE_SYMB<<8) | SE_A	// ~

// matrix controls
#define SE_ESC		(SE_CAPS<<8) | SE_SPACE
#define SE_TAB		(SE_CAPS<<8) | SE_1
#define SE_CAPSLK	(SE_CAPS<<8) | SE_2
#define SE_PGUP		(SE_CAPS<<8) | SE_3
#define SE_PGDN		(SE_CAPS<<8) | SE_4
#define SE_LEFT		(SE_CAPS<<8) | SE_5
#define SE_DOWN		(SE_CAPS<<8) | SE_6
#define SE_UP		(SE_CAPS<<8) | SE_7
#define SE_RIGHT	(SE_CAPS<<8) | SE_8
#define SE_CTRL		(SE_CAPS<<8) | SE_9
#define SE_BKSPACE	(SE_CAPS<<8) | SE_0
#define SE_ALT		(SE_CAPS<<8) | SE_SYMB
#define SE_HELP		(SE_SYMB<<8) | SE_SPACE
#define SE_INSERT	(SE_SYMB<<8) | SE_I
#define SE_CLR		(SE_SYMB<<8) | SE_RETURN
#define SE_HOME		(SE_SYMB<<8) | SE_Q
#define SE_DELETE	(SE_SYMB<<8) | SE_W
#define SE_END		(SE_SYMB<<8) | SE_E
#define SE_COMPOSE	(SE_CAPS<<8) | SE_RETURN
// END of matrix keys definitions

// Definitions for additional signals generated by the keyboard core
// AAADDDDD AAADDDDD MRN JJJJJ MMM XXXXX
#define MODIFIER1  0x20
#define MODIFIER2  0x40
#define MODIFIER3  0x80

#define MRESET     0x80
#define URESET     0x40
#define NMI        0x20

#define JOYUP      0x10
#define JOYDOWN    0x08
#define JOYLEFT    0x04
#define JOYRIGHT   0x02
#define JOYFIRE    0x01

#define USER1      0x10
#define USER2      0x08
#define USER3      0x04
#define USER4      0x02
#define USER5      0x01
// End of additional signals

// A key can be pressed with up to three key modifiers
// which generates 8 combinations for each key
#define EXT			0x080
#define MD_SHIFT	0x100
#define MD_CTRL		0x200
#define MD_ALT		0x400

#define MAP(pc,sp,rj,mu) {							\
	rom[(pc)*4] = (((sp)>>8)&0xFF);					\
	rom[(pc)*4+1] = (((sp))&0xFF);					\
	rom[(pc)*4+2] = (rj);							\
	rom[(pc)*4+3] = (mu);							\
	}
							
#define MAPANY(pc,sp,rj,mu) {						\
	MAP(pc,sp,rj,mu);								\
	MAP(MD_SHIFT|pc,sp,rj,mu);						\
	MAP(MD_CTRL|pc,sp,rj,mu);						\
	MAP(MD_ALT|pc,sp,rj,mu);						\
	MAP(MD_SHIFT|MD_CTRL|pc,sp,rj,mu);				\
	MAP(MD_SHIFT|MD_ALT|pc,sp,rj,mu);				\
	MAP(MD_CTRL|MD_ALT|pc,sp,rj,mu);				\
	MAP(MD_SHIFT|MD_CTRL|MD_ALT|pc,sp,rj,mu);		\
	}
							
#define CLEANMAP {									\
	int i;											\
	for (i=0;i<(sizeof(rom)/sizeof(rom[0]));i++)	\
	rom[i] = 0;										\
	}

#define SAVEMAPHEX(name) {							\
	FILE *f;										\
	int i;											\
	f=fopen(name,"w");								\
	for(i=0;i<(sizeof(rom)/sizeof(rom[0]));i++)		\
	fprintf(f,"%.2X\n",rom[i]);						\
	fclose(f);										\
	}

#define SAVEMAPBIN(name) {							\
	FILE *f;										\
	f=fopen(name,"wb");								\
	fwrite (rom, 1, sizeof(rom), f);				\
	fclose(f);										\
	}

// scan code 2 list

// ROW 0
#define PC_ESC      0x0e        // key to left of '1'
#define PC_F0		0x76        // ESC
#define PC_F1		0x05
#define PC_F2		0x06
#define PC_F3		0x04
#define PC_F4		0x0C
#define PC_F5		0x03
#define PC_F6		0x0B
#define PC_F7		0x83
#define PC_F8		0x0A
#define PC_F9		0x01
#define PC_F10		0x09
#define PC_F11		0x78
#define PC_F12		0x07
#define PC_F13		0x7C | EXT	// PR SCR
#define PC_F14		0x7E		// SCR LK
#define PC_F15		0x77 | EXT	// PAUSE
#define PC_DELETE	0x71 | EXT

// ROW 1
#define PC_GRAVE	0x0E		// also ~
#define PC_1		0x16		// also !
#define PC_2		0x1E		// also @
#define PC_3		0x26		// also #
#define PC_4		0x25		// also $
#define PC_5		0x2E		// also %
#define PC_6		0x36		// also ^
#define PC_7		0x3D		// also &
#define PC_8		0x3E		// also *
#define PC_9		0x46		// also (
#define PC_0		0x45		// also )
#define PC_MINUS	0x4E		// also _
#define PC_EQUALS	0x55		// also +
#define PC_BKSPACE	0x66
#define PC_HOME		0x6C | EXT

// ROW 2
#define PC_TAB		0x0D
#define PC_Q		0x15
#define PC_W		0x1D
#define PC_E		0x24
#define PC_R		0x2D
#define PC_T		0x2C
#define PC_Y		0x35
#define PC_U		0x3C
#define PC_I		0x43
#define PC_O		0x44
#define PC_P		0x4D
#define PC_LSQB		0x54		// also {
#define PC_RSQB		0x5B		// also }
#define PC_BSOL		0x5D		// also |
#define PC_PGUP		0x7D | EXT

// ROW 3
#define PC_CAPSLK	0x58
#define PC_A		0x1C
#define PC_S		0x1B
#define PC_D		0x23
#define PC_F		0x2B
#define PC_G		0x34
#define PC_H		0x33
#define PC_J		0x3B
#define PC_K		0x42
#define PC_L		0x4B
#define PC_SEMI		0x4C		// also :
#define PC_APOS		0x52		// also "
#define PC_RETURN	0x5A
#define PC_PGDN		0x7A | EXT

// ROW 4
#define PC_LSHIFT	0x12
#define PC_Z		0x1A
#define PC_X		0x22
#define PC_C		0x21
#define PC_V		0x2A
#define PC_B		0x32
#define PC_N		0x31
#define PC_M		0x3A
#define PC_COMMA	0x41		// also <
#define PC_PERIOD	0x49		// also >
#define PC_SOL		0x4A		// also ?
#define PC_RSHIFT	0x59
#define PC_UP		0x75 | EXT
#define PC_END		0x69 | EXT

// ROW 5
#define PC_LCTRL	0x14
#define PC_LWIN		0x1F | EXT
#define PC_LALT		0x11
#define PC_SPACE	0x29
#define PC_RALT		0x11 | EXT
#define PC_APPS		0x2F | EXT
#define PC_RCTRL	0x14 | EXT
#define PC_INSERT	0x70 | EXT
#define PC_LEFT		0x6B | EXT
#define PC_DOWN		0x72 | EXT
#define PC_RIGHT	0x74 | EXT

// FN modifiers
#define PC_RWIN		0x27 | EXT
#define PC_NUMLK	0x77
#define PC_KP_DIV	0x4A | EXT
#define PC_KP_MULT	0x7C
#define PC_KP_MINUS	0x7B
#define PC_KP_PLUS	0x79
#define PC_KP_ENTER	0x5A | EXT
#define PC_KP_DOT	0x71
#define PC_KP_0		0x70
#define PC_KP_1		0x69
#define PC_KP_2		0x72
#define PC_KP_3		0x7A
#define PC_KP_4		0x6B
#define PC_KP_5		0x73
#define PC_KP_6		0x74
#define PC_KP_7		0x6C
#define PC_KP_8		0x75
#define PC_KP_9		0x7D

// end of PC keyboard defines

int main()
{
	BYTE rom[16384];

	CLEANMAP;

	MAPANY(PC_LCTRL,SE_CTRL,0,0);	// CONTROL
	MAPANY(PC_LWIN,SE_SYMB,0,0);	// KORU
	MAPANY(PC_LALT,SE_ALT,0,0);		// ALTERNATE
 	MAPANY(PC_RALT,SE_ALT,0,0);		// ALTERNATE
	MAPANY(PC_RWIN,SE_SYMB,0,0);	// KORU   
	MAPANY(PC_APPS,SE_COMPOSE,0,0);	// COMPOSE 
	MAPANY(PC_RCTRL,SE_CTRL,0,0);	// CONTROL 

	// Basic mapping: each key from PC is mapped to a key in the Spectrum
	MAP(PC_1,SE_1,0,0);
	MAP(PC_2,SE_2,0,0);
	MAP(PC_3,SE_3,0,0);
	MAP(PC_4,SE_4,0,0);
	MAP(PC_5,SE_5,0,0);
	MAP(PC_6,SE_6,0,0);
	MAP(PC_7,SE_7,0,0);
	MAP(PC_8,SE_8,0,0);
	MAP(PC_9,SE_9,0,0);
	MAP(PC_0,SE_0,0,0);

	MAP(PC_Q,SE_Q,0,0);
	MAP(PC_W,SE_W,0,0);
	MAP(PC_E,SE_E,0,0);
	MAP(PC_R,SE_R,0,0);
	MAP(PC_T,SE_T,0,0);
	MAP(PC_Y,SE_Y,0,0);
	MAP(PC_U,SE_U,0,0);
	MAP(PC_I,SE_I,0,0);
	MAP(PC_O,SE_O,0,0);
	MAP(PC_P,SE_P,0,0);
	MAP(PC_A,SE_A,0,0);
	MAP(PC_S,SE_S,0,0);
	MAP(PC_D,SE_D,0,0);
	MAP(PC_F,SE_F,0,0);
	MAP(PC_G,SE_G,0,0);
	MAP(PC_H,SE_H,0,0);
	MAP(PC_J,SE_J,0,0);
	MAP(PC_K,SE_K,0,0);
	MAP(PC_L,SE_L,0,0);
	MAP(PC_Z,SE_Z,0,0);
	MAP(PC_X,SE_X,0,0);
	MAP(PC_C,SE_C,0,0);
	MAP(PC_V,SE_V,0,0);
	MAP(PC_B,SE_B,0,0);
	MAP(PC_N,SE_N,0,0);
	MAP(PC_M,SE_M,0,0);

	MAP(MD_SHIFT|PC_Q,SE_CAPS<<8|SE_Q,0,0);
	MAP(MD_SHIFT|PC_W,SE_CAPS<<8|SE_W,0,0);
	MAP(MD_SHIFT|PC_E,SE_CAPS<<8|SE_E,0,0);
	MAP(MD_SHIFT|PC_R,SE_CAPS<<8|SE_R,0,0);
	MAP(MD_SHIFT|PC_T,SE_CAPS<<8|SE_T,0,0);
	MAP(MD_SHIFT|PC_Y,SE_CAPS<<8|SE_Y,0,0);
	MAP(MD_SHIFT|PC_U,SE_CAPS<<8|SE_U,0,0);
	MAP(MD_SHIFT|PC_I,SE_CAPS<<8|SE_I,0,0);
	MAP(MD_SHIFT|PC_O,SE_CAPS<<8|SE_O,0,0);
	MAP(MD_SHIFT|PC_P,SE_CAPS<<8|SE_P,0,0);
	MAP(MD_SHIFT|PC_A,SE_CAPS<<8|SE_A,0,0);
	MAP(MD_SHIFT|PC_S,SE_CAPS<<8|SE_S,0,0);
	MAP(MD_SHIFT|PC_D,SE_CAPS<<8|SE_D,0,0);
	MAP(MD_SHIFT|PC_F,SE_CAPS<<8|SE_F,0,0);
	MAP(MD_SHIFT|PC_G,SE_CAPS<<8|SE_G,0,0);
	MAP(MD_SHIFT|PC_H,SE_CAPS<<8|SE_H,0,0);
	MAP(MD_SHIFT|PC_J,SE_CAPS<<8|SE_J,0,0);
	MAP(MD_SHIFT|PC_K,SE_CAPS<<8|SE_K,0,0);
	MAP(MD_SHIFT|PC_L,SE_CAPS<<8|SE_L,0,0);
	MAP(MD_SHIFT|PC_Z,SE_CAPS<<8|SE_Z,0,0);
	MAP(MD_SHIFT|PC_X,SE_CAPS<<8|SE_X,0,0);
	MAP(MD_SHIFT|PC_C,SE_CAPS<<8|SE_C,0,0);
	MAP(MD_SHIFT|PC_V,SE_CAPS<<8|SE_V,0,0);
	MAP(MD_SHIFT|PC_B,SE_CAPS<<8|SE_B,0,0);
	MAP(MD_SHIFT|PC_N,SE_CAPS<<8|SE_N,0,0);
	MAP(MD_SHIFT|PC_M,SE_CAPS<<8|SE_M,0,0);

	MAPANY(PC_SPACE,SE_SPACE,0,0);
	MAPANY(PC_RETURN,SE_RETURN,0,0);

	// Complex mapping. This is for the US keyboard although many
	// combos can be used with any other PC keyboard
	MAPANY(PC_ESC,SE_ESC,0,0);
	MAPANY(PC_CAPSLK,SE_CAPSLK,0,0);
	MAPANY(PC_TAB,SE_TAB,0,0);
	MAP(PC_BKSPACE,SE_BKSPACE,0,0);
	MAPANY(PC_UP,SE_UP,0,0);
	MAPANY(PC_DOWN,SE_DOWN,0,0);
	MAPANY(PC_LEFT,SE_LEFT,0,0);
	MAPANY(PC_RIGHT,SE_RIGHT,0,0);

	MAP(PC_INSERT,SE_INSERT,0,0);
	MAP(PC_INSERT|MD_SHIFT,SE_HELP,0,0);
	MAPANY(PC_DELETE,SE_DELETE,0,0);
	MAP(PC_HOME,SE_HOME,0,0);
	MAP(PC_HOME|MD_SHIFT,SE_CLR,0,0);
	MAPANY(PC_END,SE_END,0,0);
	MAPANY(PC_PGUP,SE_PGUP,0,0);
	MAPANY(PC_PGDN,SE_PGDN,0,0);

	MAPANY(PC_F0,0,NMI,0);								// F0 for NMI
    MAP(PC_ESC|MD_SHIFT|MD_CTRL,0,URESET,0);			// Ctrl-Alt-Del for user reset
    MAP(PC_ESC|MD_SHIFT|MD_CTRL|MD_ALT,0,MRESET,0);		// Ctrl-Alt-BkSpace for master reset

	//keypad
	MAPANY(PC_KP_DIV,SE_SOL,0,0);
	MAPANY(PC_KP_MULT,SE_AST,0,0);
	MAPANY(PC_KP_MINUS,SE_MINUS,0,0);
	MAPANY(PC_KP_PLUS,SE_PLUS,0,0);
	MAPANY(PC_KP_ENTER,SE_RETURN,0,0);
	MAPANY(PC_KP_0,SE_0,0,0);
	MAPANY(PC_KP_1,SE_1,0,0);
	MAPANY(PC_KP_2,SE_2,0,0);
	MAPANY(PC_KP_3,SE_3,0,0);
	MAPANY(PC_KP_4,SE_4,0,0);
	MAPANY(PC_KP_5,SE_5,0,0);
	MAPANY(PC_KP_6,SE_6,0,0);
	MAPANY(PC_KP_7,SE_7,0,0);
	MAPANY(PC_KP_8,SE_8,0,0);
	MAPANY(PC_KP_9,SE_9,0,0);

	//Some keys and shift+key mappings for the US keyboard
	MAP(MD_SHIFT|PC_1,SE_EXCL,0,0);
	MAP(MD_SHIFT|PC_2,SE_COMMAT,0,0);
	MAP(MD_SHIFT|PC_3,SE_NUM,0,0);
	MAP(MD_SHIFT|PC_4,SE_DOLLAR,0,0);
	MAP(MD_SHIFT|PC_5,SE_PERCEN,0,0);
	MAP(MD_SHIFT|PC_6,SE_CARET,0,0);
	MAP(MD_SHIFT|PC_7,SE_AMP,0,0);
	MAP(MD_SHIFT|PC_8,SE_AST,0,0);
	MAP(MD_SHIFT|PC_9,SE_LPAR,0,0);
	MAP(MD_SHIFT|PC_0,SE_RPAR,0,0);
	MAP(PC_MINUS,SE_MINUS,0,0);
	MAP(MD_SHIFT|PC_MINUS,SE_LOWBAR,0,0);
	MAP(PC_EQUALS,SE_EQUALS,0,0);
	MAP(MD_SHIFT|PC_EQUALS,SE_PLUS,0,0);
	MAP(PC_LSQB,SE_LSQB,0,0);
	MAP(MD_SHIFT|PC_LSQB,SE_LCUB,0,0);
	MAP(PC_RSQB,SE_RSQB,0,0);
	MAP(MD_SHIFT|PC_RSQB,SE_RSQB,0,0);
	MAP(PC_BSOL,SE_BSOL,0,0);
	MAP(MD_SHIFT|PC_BSOL,SE_VERBAR,0,0);
	MAP(PC_APOS,SE_APOS,0,0);
	MAP(MD_SHIFT|PC_APOS,SE_QUOT,0,0);
	MAP(PC_COMMA,SE_COMMA,0,0);
	MAP(MD_SHIFT|PC_COMMA,SE_LT,0,0);
	MAP(PC_PERIOD,SE_PERIOD,0,0);
	MAP(MD_SHIFT|PC_PERIOD,SE_GT,0,0);
	MAP(PC_SOL,SE_SOL,0,0);
	MAP(MD_SHIFT|PC_SOL,SE_QUEST,0,0);
	MAP(PC_SEMI,SE_SEMI,0,0);
	MAP(MD_SHIFT|PC_SEMI,SE_COLON,0,0);
	MAP(PC_GRAVE,SE_GRAVE,0,0);
	MAP(MD_SHIFT|PC_GRAVE,SE_TILDE,0,0);

	// End of mapping. Save .HEX file for Verilog
	//SAVEMAP1HEX("keyb1_us_hex.txt");
	//SAVEMAP2HEX("keyb2_us_hex.txt");
	// And map file for loading from ESXDOS
	SAVEMAPBIN("CHLOEV2");
	
	return 0;
}
